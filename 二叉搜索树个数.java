class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2; i <= n; i++){//这层循环代表总结点数分别从2增加到n时，各种情况下对应的二叉搜索树的个数
            for(int j=1; j <= i; j++){//这层循环代表分别以1--i为根节点的二叉搜索树的个数的总和
                dp[i] += dp[j-1] * dp[i-j];//这也是动态规划的精髓,上一层的最优解总归是要基于下一层的最优解。之所以这样写，
                 //是因为子问题的最优解就是上一层的根节点左右两部分解下来的结果数的乘积。上一层根节点的左边有j-1个节点，右边有i-j个节点
            }
        }
        return dp[n];
    }
}